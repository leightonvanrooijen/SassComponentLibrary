There is a little demo:
```bash
npm install
npm run dev
```

# Design System

## Requirements

* Consistent and flexible colour schemes
* Consistent and flexible typography
* Document design decisions
* Ability separately theme different applications
* Components are independently releasable

## UX design system:

* **Primitives** - atomic values for colours, spacing, etc.
* **Design tokens** - component specific values for colours, spacing, etc.
* **Theme** - a collection of design tokens used to theme the application
* **Components** - reusable components that designs are made up of

## Colour Primitives

Global CSS variables are used. This should represent every colour used throughout your application.

```css
:root {
    --grey50: #fafafa;
    --grey100: #f5f5f5;
    --grey200: #eeeeee;
    --grey300: #e0e0e0;
    --grey400: #bdbdbd;
    --grey500: #9e9e9e;
    --grey600: #757575;
    --grey700: #616161;
    --grey800: #424242;
    --grey900: #212121;
}
```

## Theming

### Design tokens

Global CSS variables are used. We assign each them-able property to a global variable then add the class to the parent
element that's children should be themed.

```css

.themeName {
    --buttonBackground__Primary: var(--blue500);
    --buttonBackgroundHover__Primary: var(--blue600);
}
```

It is then used in the component via the css module.

```css
/*button.module.scss*/
.button {
    background-color: var(--buttonBackground__Primary);

    &:hover {
        background-color: var(--buttonBackgroundHover__Primary);
    }
}
```

### Typography

Global CSS variables are used to specify each font aspect. As we want to group properties together we can create mixins
to apply the styles into different components.

```scss
.themeName {
  --bodyFontFamily__Regular: Helvetica, Arial, sans-serif;
  --bodySize__Regular: 16px;
  --bodyWeight__Regular: 800;
}

@mixin bodyFont__Regular {
  font-family: var(--bodyFontFamily__Regular);
  font-size: var(--bodySize__Regular);
  font-weight: var(--bodyWeight__Regular);
}

.class {
  @include bodyFont__Regular;
}
```
This should also be able to be applied to style reuse. I.e text input styles could be reused in a dropdown. I'm unsure if this
is better or worse than just composing components?

### Theme toggling

Done via a class on the root element.

```js
<html lang="en" class="lightTheme">Content</html>

const toggleTheme = () => {
    const html = document.querySelector('html');
    html.classList.toggle('lightTheme');
    html.classList.toggle('darkTheme');
}
```

### Theme nesting

Done by adding the theme class to any parent element.

```html

<div class="lightTheme">
    <button>Uses light theme</button>

    <div class="darkTheme"> // Any nested elements will use the dark theme
        <button>Uses dark theme</button>
    </div>

    <button>Uses light theme</button>
</div>
```

### Generating themes

Themes are generated by a script that takes a theme map and generates a theme file for each theme.
TODO: this can support primitives too.

```js
// themeMap.js
export const themeMap = {
    light: {
        buttonBackground__Primary: '#2196f3',
        buttonBackgroundHover__Primary: '#1976d2',
    },
    dark: {
        buttonBackground__Primary: '#1976d2',
        buttonBackgroundHover__Primary: '#1565c0',
    },
}
```

Then run `npx ts-node app/themeGenerator.ts` to generate the themes. This will create theme.css file.

## Variants, Sizing and other adjustable properties

Variants, sizing and other adjustable properties are styled via individual classes applied along side a base class.
Applying variant classes to components are managed by CVA.

```scss
// Button.module.scss
.base {
  display: inline-flex;
  flex-direction: row;
}

.primary {
  background-color: var(--buttonBackground__Primary);
}

.secondary {
  background-color: var(--buttonBackground__Secondary);
}

.small {
  padding: 0.5rem;
}

.medium {
  padding: 1rem;
}
```

```jsx
// Button.jsx
const button = cva('base',{
    intent: {
        primary: 'primary',
        secondary: 'secondary',
    },
    size: {
        small: 'small',
        medium: 'medium',
    },
})

const Button = ({variant, size, children}) => {
    return (
        <button className={button({variant, size})}>{children}</button>
    )
}
```

```

# Questions

* How do we support versioning of components and there themes?
* SCSS theme map solution bundle size vs this
* How do we reuse styles across components? Mixins?


